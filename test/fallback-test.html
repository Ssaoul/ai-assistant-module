<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast-First Fallback ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .log-area { background: #000; color: #00ff00; padding: 15px; border-radius: 5px; max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .test-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0; }
        .test-btn { padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
        .test-btn:hover { background: #45a049; }
        .status { padding: 5px 10px; border-radius: 3px; margin: 5px 0; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .config-section { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
        .config-item { margin: 10px 0; }
        .config-item label { display: inline-block; width: 150px; font-weight: bold; }
        .config-item input { padding: 5px; border: 1px solid #ddd; border-radius: 3px; width: 300px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Fast-First Fallback ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸</h1>
            <p>OpenAI ë¹ ë¥¸ ì²˜ë¦¬ â†’ HyperCLOVA X ë§¥ë½ íŒŒì•… ì „ëµ í…ŒìŠ¤íŠ¸</p>
        </div>

        <div class="config-section">
            <h3>ğŸ”§ API ì„¤ì • (ìë™ ì„¤ì •ë¨)</h3>
            <div class="config-item">
                <label>OpenAI API Key:</label>
                <input type="password" id="openaiKey" placeholder="Enter OpenAI API Key" />
            </div>
            <div class="config-item">
                <label>HyperCLOVA API Key:</label>
                <input type="password" id="hyperclovaKey" placeholder="Enter HyperCLOVA API Key" />
            </div>
            <button class="test-btn" onclick="initializeAssistant()">ğŸ¯ AI Assistant ì´ˆê¸°í™”</button>
            <div id="initStatus"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š Fast-First Fallback ì „ëµ í…ŒìŠ¤íŠ¸</h3>
            <p><strong>ì „ëµ:</strong> OpenAI 2ì´ˆ íƒ€ì„ì•„ì›ƒ â†’ ì‹¤íŒ¨ì‹œ HyperCLOVA X ë§¥ë½ ë¶„ì„</p>
            
            <div class="test-buttons">
                <button class="test-btn" onclick="testOpenAIFastSuccess()">âœ… OpenAI ë¹ ë¥¸ ì„±ê³µ (1ë‹¨ê³„)</button>
                <button class="test-btn" onclick="testOpenAITimeoutFallback()">âš ï¸ OpenAI íƒ€ì„ì•„ì›ƒ â†’ HyperCLOVA</button>
                <button class="test-btn" onclick="testKoreanCulturalContext()">ğŸ‡°ğŸ‡· í•œêµ­ ë¬¸í™” ë§¥ë½ (ë§¥ë‚ , ìŠ¤ë²…)</button>
                <button class="test-btn" onclick="testComplexKoreanExpression()">ğŸ¤” ë³µì¡í•œ í•œêµ­ì–´ í‘œí˜„</button>
                <button class="test-btn" onclick="testPerformanceComparison()">âš¡ ì„±ëŠ¥ ë¹„êµ í…ŒìŠ¤íŠ¸</button>
                <button class="test-btn" onclick="runFullFallbackTest()">ğŸ”„ ì „ì²´ Fallback ì‹œë‚˜ë¦¬ì˜¤</button>
            </div>
            
            <div id="testResults"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“ ì‹¤ì‹œê°„ ë¡œê·¸</h3>
            <button onclick="clearLogs()">ğŸ—‘ï¸ ë¡œê·¸ ì§€ìš°ê¸°</button>
            <div id="logArea" class="log-area"></div>
        </div>
    </div>

    <script src="../src/standalone/ai-assistant-standalone.js"></script>
    <script>
        let assistant = null;
        let testResults = [];

        function log(message, type = 'info') {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
            logArea.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
            console.log(message);
        }

        function clearLogs() {
            document.getElementById('logArea').innerHTML = '';
        }

        function updateTestResults() {
            const resultsDiv = document.getElementById('testResults');
            const successCount = testResults.filter(r => r.success).length;
            const totalCount = testResults.length;
            
            resultsDiv.innerHTML = `
                <div class="status ${totalCount > 0 ? (successCount === totalCount ? 'success' : 'info') : ''}">
                    ğŸ“Š í…ŒìŠ¤íŠ¸ ê²°ê³¼: ${successCount}/${totalCount} ì„±ê³µ (${totalCount > 0 ? Math.round(successCount/totalCount*100) : 0}%)
                </div>
                ${testResults.map(r => `
                    <div class="status ${r.success ? 'success' : 'error'}">
                        ${r.success ? 'âœ…' : 'âŒ'} ${r.name}: ${r.message} 
                        ${r.timing ? `(${r.timing}ms)` : ''}
                    </div>
                `).join('')}
            `;
        }

        async function initializeAssistant() {
            try {
                const openaiKey = document.getElementById('openaiKey').value;
                const hyperclovaKey = document.getElementById('hyperclovaKey').value;

                if (!openaiKey || !hyperclovaKey) {
                    document.getElementById('initStatus').innerHTML = '<div class="status error">âŒ API í‚¤ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”</div>';
                    return;
                }

                assistant = new AIAssistantStandalone({
                    openaiApiKey: openaiKey,
                    hyperclovaApiKey: hyperclovaKey,
                    language: 'ko-KR'
                });

                document.getElementById('initStatus').innerHTML = '<div class="status success">âœ… AI Assistant ì´ˆê¸°í™” ì™„ë£Œ</div>';
                log('ğŸ¯ AI Assistant ì´ˆê¸°í™” ì™„ë£Œ - Fast-First Fallback ì „ëµ í™œì„±í™”', 'success');
                
            } catch (error) {
                document.getElementById('initStatus').innerHTML = `<div class="status error">âŒ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}</div>`;
                log(`âŒ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }

        async function testOpenAIFastSuccess() {
            if (!assistant) {
                log('âŒ AI Assistantê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('ğŸš€ í…ŒìŠ¤íŠ¸ 1: OpenAI ë¹ ë¥¸ ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤', 'info');
            const startTime = Date.now();
            
            try {
                const result = await assistant.processCommand("ìŒì•… ì¬ìƒí•´ì¤˜");
                const endTime = Date.now();
                const timing = endTime - startTime;
                
                if (result && result.source === 'openai') {
                    testResults.push({
                        name: 'OpenAI ë¹ ë¥¸ ì„±ê³µ',
                        success: true,
                        timing,
                        message: `OpenAI 1ë‹¨ê³„ ì„±ê³µ (${result.confidence} ì‹ ë¢°ë„)`
                    });
                    log(`âœ… OpenAI ë¹ ë¥¸ ì²˜ë¦¬ ì„±ê³µ: ${timing}ms`, 'success');
                } else {
                    testResults.push({
                        name: 'OpenAI ë¹ ë¥¸ ì„±ê³µ',
                        success: false,
                        timing,
                        message: 'OpenAI ëŒ€ì‹  ë‹¤ë¥¸ ì†ŒìŠ¤ ì‚¬ìš©ë¨'
                    });
                    log(`âŒ ì˜ˆìƒê³¼ ë‹¤ë¥¸ ê²°ê³¼: ${JSON.stringify(result)}`, 'error');
                }
            } catch (error) {
                testResults.push({
                    name: 'OpenAI ë¹ ë¥¸ ì„±ê³µ',
                    success: false,
                    message: error.message
                });
                log(`âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
            
            updateTestResults();
        }

        async function testKoreanCulturalContext() {
            if (!assistant) {
                log('âŒ AI Assistantê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('ğŸ‡°ğŸ‡· í…ŒìŠ¤íŠ¸ 3: í•œêµ­ ë¬¸í™” ë§¥ë½ í…ŒìŠ¤íŠ¸', 'info');
            const testCases = [
                { input: "ë§¥ë‚  ê²€ìƒ‰í•´ì¤˜", expected: "ë§¥ë„ë‚ ë“œ" },
                { input: "ìŠ¤ë²… ì°¾ì•„ì¤˜", expected: "ìŠ¤íƒ€ë²…ìŠ¤" },
                { input: "ì¹´í†¡ ì—´ì–´ì¤˜", expected: "ì¹´ì¹´ì˜¤í†¡" }
            ];

            for (const testCase of testCases) {
                const startTime = Date.now();
                try {
                    log(`ğŸ” í…ŒìŠ¤íŠ¸: "${testCase.input}"`);
                    const result = await assistant.processCommand(testCase.input);
                    const endTime = Date.now();
                    const timing = endTime - startTime;

                    const success = result && (
                        result.target?.includes(testCase.expected) || 
                        result.intent?.includes(testCase.expected) ||
                        (result.source === 'hyperclova_cultural')
                    );

                    testResults.push({
                        name: `í•œêµ­ ë¬¸í™” ë§¥ë½: ${testCase.input}`,
                        success,
                        timing,
                        message: success ? `${testCase.expected} ì •í™•íˆ ì¸ì‹` : `ì˜ˆìƒ: ${testCase.expected}, ì‹¤ì œ: ${result?.target}`
                    });

                    log(`${success ? 'âœ…' : 'âŒ'} "${testCase.input}" â†’ ${result?.target} (${timing}ms)`, success ? 'success' : 'error');
                } catch (error) {
                    testResults.push({
                        name: `í•œêµ­ ë¬¸í™” ë§¥ë½: ${testCase.input}`,
                        success: false,
                        message: error.message
                    });
                    log(`âŒ "${testCase.input}" ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            }

            updateTestResults();
        }

        async function testComplexKoreanExpression() {
            if (!assistant) {
                log('âŒ AI Assistantê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('ğŸ¤” í…ŒìŠ¤íŠ¸ 4: ë³µì¡í•œ í•œêµ­ì–´ í‘œí˜„', 'info');
            const complexExpressions = [
                "ê·¸ê±° ìˆì–ì•„, ë°° ê³ í”Œ ë•Œ ì‹œí‚¤ëŠ” ê·¸ê±° ë§ì´ì•¼",
                "ì•„ê¹Œ ê·¸ ë²„íŠ¼ ìˆì—ˆëŠ”ë°, ë­ì˜€ì§€?",
                "ìš”ì¦˜ ë‚ ì”¨ê°€ ì–´ë–¤ì§€ ì¢€ ì•Œì•„ë´ì¤˜"
            ];

            for (const expression of complexExpressions) {
                const startTime = Date.now();
                try {
                    log(`ğŸ” ë³µì¡í•œ í‘œí˜„: "${expression}"`);
                    const result = await assistant.processCommand(expression);
                    const endTime = Date.now();
                    const timing = endTime - startTime;

                    const success = result && (result.confidence >= 0.6 || result.source === 'hyperclova-context');

                    testResults.push({
                        name: `ë³µì¡í•œ í•œêµ­ì–´: ${expression.substring(0, 20)}...`,
                        success,
                        timing,
                        message: `${result?.source} ì†ŒìŠ¤, ${result?.confidence} ì‹ ë¢°ë„`
                    });

                    log(`${success ? 'âœ…' : 'âŒ'} ë³µì¡í•œ í‘œí˜„ ì²˜ë¦¬ ${success ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'} (${timing}ms)`, success ? 'success' : 'error');
                } catch (error) {
                    testResults.push({
                        name: `ë³µì¡í•œ í•œêµ­ì–´: ${expression.substring(0, 20)}...`,
                        success: false,
                        message: error.message
                    });
                    log(`âŒ ë³µì¡í•œ í‘œí˜„ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            }

            updateTestResults();
        }

        async function testPerformanceComparison() {
            if (!assistant) {
                log('âŒ AI Assistantê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('âš¡ í…ŒìŠ¤íŠ¸ 5: ì„±ëŠ¥ ë¹„êµ', 'info');
            const testCommand = "ìŒì•… ì¬ìƒ";
            const trials = 3;
            let openaiTimes = [];
            let hyperclovaTimes = [];

            // OpenAI ì„±ëŠ¥ ì¸¡ì •
            log('ğŸ“Š OpenAI ì„±ëŠ¥ ì¸¡ì • ì¤‘...', 'info');
            for (let i = 0; i < trials; i++) {
                const startTime = Date.now();
                try {
                    const result = await assistant.processCommand(testCommand);
                    const endTime = Date.now();
                    if (result?.source === 'openai') {
                        openaiTimes.push(endTime - startTime);
                        log(`OpenAI ì‹œë„ ${i + 1}: ${endTime - startTime}ms`);
                    }
                } catch (error) {
                    log(`OpenAI ì‹œë„ ${i + 1} ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            }

            const avgOpenAI = openaiTimes.length > 0 ? Math.round(openaiTimes.reduce((a, b) => a + b) / openaiTimes.length) : 0;
            
            testResults.push({
                name: 'OpenAI í‰ê·  ì„±ëŠ¥',
                success: avgOpenAI > 0 && avgOpenAI < 2000,
                timing: avgOpenAI,
                message: `í‰ê·  ${avgOpenAI}ms (${openaiTimes.length}/${trials} ì„±ê³µ)`
            });

            log(`ğŸ“ˆ ì„±ëŠ¥ ë¹„êµ ì™„ë£Œ - OpenAI í‰ê· : ${avgOpenAI}ms`, avgOpenAI > 0 ? 'success' : 'error');
            updateTestResults();
        }

        async function runFullFallbackTest() {
            if (!assistant) {
                log('âŒ AI Assistantê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            log('ğŸ”„ í…ŒìŠ¤íŠ¸ 6: ì „ì²´ Fallback ì‹œë‚˜ë¦¬ì˜¤', 'info');
            
            // í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤: OpenAI ë¹ ë¦„ â†’ ì‹¤íŒ¨ ì‹œ HyperCLOVA X ë§¥ë½ íŒŒì•…
            const scenarios = [
                { 
                    name: "ê°„ë‹¨í•œ ëª…ë ¹ (OpenAI ì²˜ë¦¬ ì˜ˆìƒ)",
                    command: "ê²€ìƒ‰í•´ì¤˜",
                    expectedSource: "openai",
                    maxTime: 2000
                },
                {
                    name: "í•œêµ­ ë¬¸í™” ë§¥ë½ (HyperCLOVA ì²˜ë¦¬ ì˜ˆìƒ)",
                    command: "ë§¥ë‚  ì£¼ë¬¸í•˜ê³  ì‹¶ì–´",
                    expectedPattern: "ë§¥ë„ë‚ ë“œ",
                    maxTime: 5000
                },
                {
                    name: "ë³µì¡í•œ ì˜ë„ (Fallback ì²˜ë¦¬)",
                    command: "ì•„ê¹Œ ê·¸ê±° ìˆì–ì•„, ê·¸ ë²„íŠ¼ ë§ì´ì•¼",
                    expectedFallback: true,
                    maxTime: 6000
                }
            ];

            for (const scenario of scenarios) {
                log(`ğŸ¯ ì‹œë‚˜ë¦¬ì˜¤: ${scenario.name}`, 'info');
                const startTime = Date.now();
                
                try {
                    const result = await assistant.processCommand(scenario.command);
                    const endTime = Date.now();
                    const timing = endTime - startTime;

                    let success = false;
                    let message = '';

                    if (scenario.expectedSource && result?.source === scenario.expectedSource) {
                        success = timing <= scenario.maxTime;
                        message = `${scenario.expectedSource} ì˜ˆìƒëŒ€ë¡œ ì²˜ë¦¬ (${timing}ms)`;
                    } else if (scenario.expectedPattern && result?.target?.includes(scenario.expectedPattern)) {
                        success = timing <= scenario.maxTime;
                        message = `íŒ¨í„´ "${scenario.expectedPattern}" ì •í™• ì¸ì‹ (${timing}ms)`;
                    } else if (scenario.expectedFallback && result?.source?.includes('hyperclova')) {
                        success = timing <= scenario.maxTime;
                        message = `HyperCLOVA X Fallback ì„±ê³µ (${timing}ms)`;
                    } else {
                        message = `ì˜ˆìƒê³¼ ë‹¤ë¥¸ ê²°ê³¼: ${result?.source}, ${result?.target}`;
                    }

                    testResults.push({
                        name: scenario.name,
                        success,
                        timing,
                        message
                    });

                    log(`${success ? 'âœ…' : 'âŒ'} ${scenario.name}: ${message}`, success ? 'success' : 'error');

                } catch (error) {
                    testResults.push({
                        name: scenario.name,
                        success: false,
                        message: error.message
                    });
                    log(`âŒ ${scenario.name} ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            }

            updateTestResults();
            log('ğŸ ì „ì²´ Fallback ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ ì™„ë£Œ', 'info');
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì´ˆê¸°í™”
        window.addEventListener('load', () => {
            log('ğŸ‰ Fast-First Fallback í…ŒìŠ¤íŠ¸ í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ', 'success');
            log('ğŸ”„ AI Assistant ìë™ ì´ˆê¸°í™” ì¤‘...', 'info');
            
            // 0.5ì´ˆ í›„ ìë™ ì´ˆê¸°í™”
            setTimeout(() => {
                initializeAssistant();
            }, 500);
        });
    </script>
</body>
</html>